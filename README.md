Домашнє завдання до теми “Алгоритми сортування”

Опис домашнього завдання

Python має дві вбудовані функції сортування: sorted і sort. Функції сортування Python використовують Timsort — гібридний алгоритм сортування, що поєднує в собі сортування злиттям і сортування вставками.

Порівняйте три алгоритми сортування: злиттям, вставками та Timsort за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.

Необов'язкове завдання

Дано k відсортованих списків цілих чисел. Ваше завдання — об'єднати їх у один відсортований список. При виконанні завдання можете опиратися на алгоритм сортування злиттям з конспекту. Реалізуйте функцію merge_k_lists , яка приймає на вхід список відсортованих списків та повертає відсортований список.

Приклад очікуваного результату:

lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
print("Відсортований список:", merged_list)

Виведення:

Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]

## Завдання 1:

Порівняння трьох алгоритмів сортування в Python при різних розмірах масивів (100, 500, 1000, 5000 і 10000 елементів):

## Size | Insertion | Merge | Timsort

## 100 | 0.0003 | 0.0002 | 0.0000

## 500 | 0.0141 | 0.0016 | 0.0001

## 1000 | 0.0601 | 0.0039 | 0.0002

## 5000 | 1.2201 | 0.0178 | 0.0006

## 10000 | 5.0239 | 0.0375 | 0.0014

## Висновки:

Insertion Sort дуже повільний при збільшенні розміру масиву (O(n²)). Добре працює лише на маленьких наборах.

Merge Sort набагато швидший завдяки своїй складності O(n log n), стабільний і передбачуваний.

Timsort — безумовний лідер. Він поєднує сортування злиттям і вставками, адаптується до вже відсортованих ділянок, має складність O(n log n) у гіршому випадку та O(n) у найкращому.
